(window.webpackJsonp=window.webpackJsonp||[]).push([[165],{2587:function(t,a,s){"use strict";s.r(a);var n=s(2),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"前话"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前话"}},[t._v("#")]),t._v(" 前话")]),t._v(" "),n("ul",[n("li",[t._v("在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消费者(工作进程)。在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式称为 ”发布/订阅”.")]),t._v(" "),n("li",[t._v("为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成: 第一个程序将发出日志消息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者")])]),t._v(" "),n("blockquote",[n("p",[t._v("如下图：一个消息之只能被消费一次, 也就是说一个消息被消费者 C1 或者 消费者 C2 消费一次。如果想要一个消息能被多个消费者消费，则需要经过交换机。这种就叫做 简单模式\n"),n("img",{attrs:{src:s(841),alt:""}})])]),t._v(" "),n("blockquote",[n("p",[t._v("生产者把一个消息给交换机，交换机把该消息，通过不同的 RoutingKey 转发给两个队列，这种就叫做 【发布/订阅模式】\n"),n("img",{attrs:{src:s(842),alt:""}})])]),t._v(" "),n("h2",{attrs:{id:"exchanges-交换器-交换机-概念"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#exchanges-交换器-交换机-概念"}},[t._v("#")]),t._v(" Exchanges（交换器/交换机） 概念")]),t._v(" "),n("ul",[n("li",[t._v("RabbitMQ 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。")]),t._v(" "),n("li",[t._v("相反，"),n("code",[t._v("生产者只能将消息发送到交换机(exchange)")]),t._v("，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。")])]),t._v(" "),n("p",[n("img",{attrs:{src:s(843),alt:""}})]),t._v(" "),n("h2",{attrs:{id:"exchanges-的类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#exchanges-的类型"}},[t._v("#")]),t._v(" Exchanges 的类型")]),t._v(" "),n("ul",[n("li",[t._v("总共有以下类型：\n"),n("ul",[n("li",[t._v("直接(direct)类型：也叫 路由类型。")]),t._v(" "),n("li",[t._v("主题(topic)类型")]),t._v(" "),n("li",[t._v("标题(headers)类型: 在企业中不常用了")]),t._v(" "),n("li",[t._v("扇出(fanout)类型：就是发布/订阅类型")]),t._v(" "),n("li",[t._v("无名类型")])])])]),t._v(" "),n("h2",{attrs:{id:"无名-exchange"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#无名-exchange"}},[t._v("#")]),t._v(" 无名 exchange")]),t._v(" "),n("ul",[n("li",[t._v("在本教程的前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。")])]),t._v(" "),n("div",{staticClass:"language-java line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[t._v("channel"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("basicPublic")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('""')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" message"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getBytes")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br")])]),n("ul",[n("li",[t._v("第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的话")])])])}),[],!1,null,null,null);a.default=e.exports},841:function(t,a,s){t.exports=s.p+"assets/img/21.a80a4493.png"},842:function(t,a,s){t.exports=s.p+"assets/img/22.8acdfa47.png"},843:function(t,a,s){t.exports=s.p+"assets/img/9.a6f2c7f3.png"}}]);