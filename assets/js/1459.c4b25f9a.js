(window.webpackJsonp=window.webpackJsonp||[]).push([[1459],{3500:function(v,_,t){"use strict";t.r(_);var e=t(2),l=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"面试题汇总"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面试题汇总"}},[v._v("#")]),v._v(" 面试题汇总")]),v._v(" "),t("h3",{attrs:{id:"说一下http缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说一下http缓存"}},[v._v("#")]),v._v(" 说一下http缓存")]),v._v(" "),t("p",[t("a",{attrs:{href:"https://www.bilibili.com/video/BV1Jr4y1v7Nc/?spm_id_from=333.337.search-card.all.click&vd_source=7146746363d9e7490b0326e8f02bf64a",target:"_blank",rel:"noopener noreferrer"}},[v._v("视频链接"),t("OutboundLink")],1)]),v._v(" "),t("ul",[t("li",[v._v("是什么? 缓存指的是：在客户端首次发起请求后，会保存一份响应副本，当客户端再次发起相同的请求后，如果判断缓存命中则拦截请求，将之前存储的响应副本直接返回给用户，从而避免重新向服务器发起请求。")]),v._v(" "),t("li",[v._v("能干什么？干的怎么样？http缓存分为 强制缓存 和 协商缓存")])]),v._v(" "),t("h4",{attrs:{id:"强制缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[v._v("#")]),v._v(" 强制缓存")]),v._v(" "),t("ul",[t("li",[v._v("在浏览器判断所请求的目标资源有效命中。如果命中，则直接从强制缓存中返回请求响应，无需与服务器进行任何通信")]),v._v(" "),t("li",[v._v("与强缓存相关的两个字段是 "),t("code",[v._v("expires")]),v._v(" 和 "),t("code",[v._v("cache-control")]),v._v(" "),t("ul",[t("li",[v._v("expires ：\n"),t("ul",[t("li",[v._v("是在 HTTP 1.0 协议中声明用来控制缓存失效日期时间戳的字段，它由服务器端指定后通过响应头告知浏览器，浏览器在接收到带有该字段的响应体后进行缓存。")]),v._v(" "),t("li",[v._v("若之后浏览器再次发起相同的资源请求，便会对比 "),t("code",[v._v("expires")]),v._v(" 与本地当前的时间戳，如果当前请求的本地时间戳小于 "),t("code",[v._v("expires")]),v._v(" 的值，则说明浏览器缓存的响应还未过期，可以直接使用而无需向服务器再次发起请求。只有当本地时间戳大于 "),t("code",[v._v("expires")]),v._v(" 值，则表示缓存过期，那么才允许重新向服务器发起请求。")]),v._v(" "),t("li",[t("code",[v._v("expires")]),v._v(" 缺点：上述的方式存在一个很大的漏洞，即对本地时间戳过分依赖，如果客户端的本地时间与服务器端时间不同步，或者对客户端的时间进行了主动修改，那么对于缓存过期的判断可能就无法和预期相符。")])])]),v._v(" "),t("li",[t("code",[v._v("cache-control")]),v._v(" :\n"),t("ul",[t("li",[v._v("为了解决 "),t("code",[v._v("expires")]),v._v(" 的上述缺点，从 HTTP 1.1 协议开始新增了 "),t("code",[v._v("cache-control")]),v._v(" 字段来对 "),t("code",[v._v("expires")]),v._v(" 的功能进行了扩展。"),t("code",[v._v("cache-control")]),v._v(" 通过设置 "),t("code",[v._v("max-age=31536000")]),v._v(" 的属性来控制响应资源的有效期，它是一个以秒为单位，表示该资源在被请求到达后的 31536000 秒内有效，这样就避免了服务器和客户端时间戳不同步而造成的问题。")]),v._v(" "),t("li",[v._v("cache-control 还有其他配置参数。\n"),t("ul",[t("li",[t("code",[v._v("no-cache")]),v._v(" : 并非字面上的意思不适用缓存，而是表示强制进行协商缓存，即对于每次发起的请求都不会再去判断强制缓存是否过期，而是与服务器协商，询问服务器缓存是否过期，若未过期，则会使用本地缓存。")]),v._v(" "),t("li",[t("code",[v._v("no-store")]),v._v(" : 表示禁止使用任何缓存策略，客户端的每次请求都需要服务器给与全新的响应。"),t("code",[v._v("no-cache")]),v._v(" 和 "),t("code",[v._v("no-store")]),v._v(" 不能同时设置。")]),v._v(" "),t("li",[t("code",[v._v("private")]),v._v(" : 是默认值。限制了响应资源只能被浏览器私有缓存。")]),v._v(" "),t("li",[t("code",[v._v("public")]),v._v("  : 表示响应资源既可以被浏览器私有缓存，也可以被代理服务器公共缓存。通常像一些静态资源，比如图片，就可以设置为 "),t("code",[v._v("public")]),v._v("，让代理服务器缓存。设置方式: Cache-Control: public, max-age= 31536000")]),v._v(" "),t("li",[v._v("在项目中使用 cache-control 就足够了，目前 expires 还存在的理由可能就是因为考虑到向下兼容。")])])])])])])])]),v._v(" "),t("h4",{attrs:{id:"协商缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[v._v("#")]),v._v(" 协商缓存")]),v._v(" "),t("ul",[t("li",[v._v("是什么?  在使用本地缓存之前，会先向服务器发起一次GET请求，就是会先问一下服务器这个缓存是否还有效，如果有效则使用该本地缓存。如果无效则服务器会发送最新的资源内容到客户端。")]),v._v(" "),t("li",[v._v("能干什么？干的怎么样？流程如下：\n"),t("ul",[t("li",[t("ol",[t("li",[v._v("当客户端第一次请求后，服务端给予响应，同时会在响应头添加 last-modified 字段，值就是该资源的上一次修改时间。")])])]),v._v(" "),t("li",[t("ol",{attrs:{start:"2"}},[t("li",[v._v("当客户端在次发起同样的请求，此时请求头中包含一个 if-modified-since 字段,  值就是上次响应头中 last-modified 对应的值。")])])]),v._v(" "),t("li",[t("ol",{attrs:{start:"3"}},[t("li",[v._v("服务器端会对比 【请求资源上一次修改的时间戳】 跟 【if-modified-since 字段的值】，如果二者相同则说明缓存未过期，服务器端就可以直接发送304状态码，表示浏览器端仍然可以正常使用本地缓存。如果不相同，则服务器会重新返回全新的资源")])])]),v._v(" "),t("li",[v._v("缺点：\n"),t("ul",[t("li",[t("ol",[t("li",[v._v("只是根据资源最后修改的时间戳进行判断的。如果只是修改了资源文件的名字，但是其内容并没有变化，时间戳也会更新，从而就导致了协商缓存判断失效。这无疑会造成网络带宽资源的浪费。")])])]),v._v(" "),t("li",[t("ol",{attrs:{start:"2"}},[t("li",[v._v("修改的时间戳的单位是秒，无法精确到毫秒。比如你修改资源文件的速度很快，那么就无法识别出该文件资源发生了更新。")])])])])])])])]),v._v(" "),t("h4",{attrs:{id:"基于etag的协商缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于etag的协商缓存"}},[v._v("#")]),v._v(" 基于ETag的协商缓存")]),v._v(" "),t("ul",[t("li",[v._v("是什么？为了弥补通过时间戳判断的不足，从HTTP/1.1新增了ETag的头信息，即实体标签（Entity Tag）")]),v._v(" "),t("li",[v._v("能干什么？干的怎么样？具体是怎么做：\n"),t("ul",[t("li",[v._v("主要就是服务器会为不同资源进行哈希运算，然后生成一个字符串，该字符串类似于文件的指纹，也就是说每一个文件资源都会有一个单独的指纹。只有当文件内容发生改变，那么这个指纹才会改变。")])])]),v._v(" "),t("li",[v._v("流程：\n"),t("ul",[t("li",[t("ol",[t("li",[v._v("客户端发起第一次请求后，服务器端会响应资源，同时在响应头添加 etag 资源，值就是根据响应资源生成的指纹信息。")])])]),v._v(" "),t("li",[t("ol",{attrs:{start:"2"}},[t("li",[v._v("当客户端再发起相同的请求时，会在请求头中添加 if-none-match，值就是上一次响应资源对应的指纹信息。")])])]),v._v(" "),t("li",[t("ol",{attrs:{start:"3"}},[t("li",[v._v("然后服务端会根据 【if-none-match 这个字段】 与 【对应资源的指纹】 比较，如果这两个值相同，则服务器端可以直接发送304状态码，表示浏览器端仍然可以正常使用本地缓存。")])])])])]),v._v(" "),t("li",[v._v("etag的不足：\n"),t("ul",[t("li",[t("ol",[t("li",[v._v("需要根据文件的内容生成指纹，因此需要符出额外的计算开销，影响服务器的性能。")])])])])])]),v._v(" "),t("h4",{attrs:{id:"为什么需要是缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要是缓存"}},[v._v("#")]),v._v(" 为什么需要是缓存")]),v._v(" "),t("ul",[t("li",[v._v("在任何一个前端项目中，访问服务器获取数据都是很常见的事情，但是如果相同的数据被重复请求了不止一次，那么多余的请求次数必然会浪费网络带宽，以及延迟浏览器渲染所要处理的内容，从而影响用户的使用体验。")]),v._v(" "),t("li",[v._v("如果用户使用的按量计费的方式访问网络，那么多余的请求还会增加用户的网络流量自资费。")]),v._v(" "),t("li",[v._v("因此考虑使用缓存技术对已获取的资源进行重用，是一种提升网络性能与用户体验的有效策略。")])])])}),[],!1,null,null,null);_.default=l.exports}}]);