(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{2700:function(t,s,a){"use strict";a.r(s);var e=a(2),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#是什么"}},[t._v("#")]),t._v(" 是什么")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("镜像")]),t._v(" "),e("ul",[e("li",[t._v("是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是 image 镜像文件。")]),t._v(" "),e("li",[t._v("只有通过这个镜像文件才能生成 Docker 容器实例(类似 Java 中 new 出来一个对象)。")])])]),t._v(" "),e("li",[e("p",[t._v("分层的镜像")]),t._v(" "),e("ul",[e("li",[t._v("以我们的 pull 为例，在下载的过程中我们可以看到 docker 的镜像好像是在一层一层的在下载")]),t._v(" "),e("li",[e("img",{attrs:{src:a(972),alt:""}})])])]),t._v(" "),e("li",[e("p",[t._v("UnionFS（联合文件系统）")]),t._v(" "),e("ul",[e("li",[t._v("Union 文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。")]),t._v(" "),e("li",[e("img",{attrs:{src:a(973),alt:""}})]),t._v(" "),e("li",[t._v("特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录")])])]),t._v(" "),e("li",[e("p",[t._v("Docker 镜像加载原理")]),t._v(" "),e("ul",[e("li",[t._v("docker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统 UnionFS。")]),t._v(" "),e("li",[t._v("bootfs(boot file system)主要包含 bootloader 和 kernel, bootloader 主要是引导加载 kernel, Linux 刚启动时会加载 bootfs 文件系统，在 Docker 镜像的最底层是引导文件系统 bootfs。这一层与我们典型的 Linux/Unix 系统是一样的，包含 boot 加载器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs 转交给内核，此时系统也会卸载 bootfs。")]),t._v(" "),e("li",[t._v("rootfs (root file system) ，在 bootfs 之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs 就是各种不同的操作系统发行版，比如 Ubuntu，Centos 等等。")]),t._v(" "),e("li",[e("img",{attrs:{src:a(974),alt:""}})]),t._v(" "),e("li",[t._v("平时我们安装进虚拟机的 CentOS 都是好几个 G，为什么 docker 这里才 200M？？")]),t._v(" "),e("li",[e("img",{attrs:{src:a(975),alt:""}})]),t._v(" "),e("li",[t._v("对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用 Host 的 kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的 linux 发行版, bootfs 基本是一致的, rootfs 会有差别, 因此不同的发行版可以公用 bootfs。")])])]),t._v(" "),e("li",[e("p",[t._v("为什么 Docker 镜像要采用这种分层结构呢？")]),t._v(" "),e("ul",[e("li",[t._v("镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。")]),t._v(" "),e("li",[t._v("比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；")]),t._v(" "),e("li",[t._v("同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。")])])])]),t._v(" "),e("h2",{attrs:{id:"重点理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重点理解"}},[t._v("#")]),t._v(" 重点理解")]),t._v(" "),e("ul",[e("li",[t._v("Docker 镜像层都是只读的，容器层是可写的")]),t._v(" "),e("li",[t._v("当容器启动时，一个新的可写层被加载到镜像的顶部。")]),t._v(" "),e("li",[t._v("这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。")]),t._v(" "),e("li",[t._v("当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。")]),t._v(" "),e("li",[t._v("所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。")]),t._v(" "),e("li",[e("img",{attrs:{src:a(976),alt:""}})])]),t._v(" "),e("h2",{attrs:{id:"docker-镜像-commit-操作案例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-镜像-commit-操作案例"}},[t._v("#")]),t._v(" Docker 镜像 commit 操作案例")]),t._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 提交容器副本使之成为一个新的镜像")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("docker")]),t._v(" commit\n\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("docker")]),t._v(" commit "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-m")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"提交的描述信息"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-a")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"作者"')]),t._v(" 容器 ID 要创建的目标镜像名:"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("标签名"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br")])]),e("h3",{attrs:{id:"案例演示-ubuntu-安装-vim"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#案例演示-ubuntu-安装-vim"}},[t._v("#")]),t._v(" 案例演示 ubuntu 安装 vim")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("从 Hub 上下载 ubuntu 镜像到本地并成功运行")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("原始的默认 Ubuntu 镜像是不带着 vim 命令的")])]),t._v(" "),e("ul",[e("li",[e("img",{attrs:{src:a(977),alt:""}})])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[t._v("外网连通的情况下，安装 vim")])]),t._v(" "),e("ul",[e("li",[t._v("docker 容器内执行上述两条命令：")])]),t._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 先更新我们的包管理工具")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("apt-get")]),t._v(" update\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 然后安装我们需要的 vim")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("apt-get")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-y")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("vim")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"4"}},[e("li",[t._v("安装完成后，commit 我们自己的新镜像")])]),t._v(" "),e("ul",[e("li",[e("img",{attrs:{src:a(978),alt:""}})])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"5"}},[e("li",[t._v("启动我们的新镜像并和原来的对比")])]),t._v(" "),e("ul",[e("li",[e("img",{attrs:{src:a(979),alt:""}})]),t._v(" "),e("li",[t._v("官网是默认下载的 Ubuntu 没有 vim 命令")]),t._v(" "),e("li",[t._v("我们自己 commit 构建的镜像，新增加了 vim 功能，可以成功使用。")])])])]),t._v(" "),e("h3",{attrs:{id:"小总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小总结"}},[t._v("#")]),t._v(" 小总结")]),t._v(" "),e("ul",[e("li",[t._v("Docker 中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似 Java 继承于一个 Base 基础类，自己再按需扩展。")]),t._v(" "),e("li",[t._v("新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层")]),t._v(" "),e("li",[e("img",{attrs:{src:a(980),alt:""}})])])])}),[],!1,null,null,null);s.default=r.exports},972:function(t,s,a){t.exports=a.p+"assets/img/60.13f4d5f2.png"},973:function(t,s,a){t.exports=a.p+"assets/img/61.6c820ef9.png"},974:function(t,s,a){t.exports=a.p+"assets/img/62.6e670b94.png"},975:function(t,s,a){t.exports=a.p+"assets/img/63.554f70ea.png"},976:function(t,s,a){t.exports=a.p+"assets/img/64.92bc2ee2.png"},977:function(t,s,a){t.exports=a.p+"assets/img/65.3d95f0aa.png"},978:function(t,s,a){t.exports=a.p+"assets/img/69.489a7448.png"},979:function(t,s,a){t.exports=a.p+"assets/img/70.a6805209.png"},980:function(t,s,a){t.exports=a.p+"assets/img/71.2900281c.png"}}]);