(window.webpackJsonp=window.webpackJsonp||[]).push([[407],{1609:function(t,r,i){t.exports=i.p+"assets/img/3.d347433e.png"},3366:function(t,r,i){"use strict";i.r(r);var e=i(2),a=Object(e.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"_3-fiber"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-fiber"}},[t._v("#")]),t._v(" 3 Fiber")]),t._v(" "),e("h4",{attrs:{id:"_3-1-问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-问题"}},[t._v("#")]),t._v(" 3.1 问题")]),t._v(" "),e("p",[t._v("React 16 之前的版本比对更新 VirtualDOM 的过程是采用循环加递归实现的，这种比对方式有一个问题，就是一旦任务开始进行就无法中断，如果应用中组件数量庞大，主线程被长期占用，直到整棵 VirtualDOM 树比对更新完成之后主线程才能被释放，主线程才能执行其他任务。这就会导致一些用户交互，动画等任务无法立即得到执行，页面就会产生卡顿, 非常的影响用户体验。")]),t._v(" "),e("p",[t._v("核心问题：递归无法中断，执行重任务耗时长。 JavaScript 又是单线程，无法同时执行其他任务，导致任务延迟页面卡顿，用户体验差。")]),t._v(" "),e("h4",{attrs:{id:"_3-2-解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-解决方案"}},[t._v("#")]),t._v(" 3.2 解决方案")]),t._v(" "),e("ol",[e("li",[t._v("在react新版本中，使用requestIdleCallback这个api, 利用浏览器空闲时间执行dom比对的过程，也就是virtual dom的比对过程不会长时间占用主线程，如果有高优先级的任务，那么就先终止virtual dom的比对过程，先去执行高优先级的任务，当高优先级的任务完成后，再去执行 virtual dom的比对过程, 这样页面就不会卡顿了")]),t._v(" "),e("li",[t._v("放弃递归只采用循环，因为循环可以被中断。")]),t._v(" "),e("li",[t._v("如果任务想要终止再继续，那么任务就必须要小。这样即使任务没有被执行完，而是被终止，那么重新再来执行该任务的时候，代价就比较小，所以需要做任务拆分，将任务拆分成一个个的小任务。")]),t._v(" "),e("li",[t._v("以前是将整课virtual dom树的比对作为一个任务，现在我们是将每一个树上的节点进行比对。")])]),t._v(" "),e("ul",[e("li",[e("ol",{attrs:{start:"5"}},[e("li",[t._v("fiber的含义是纤维，意思就是说执行任务的颗粒度变小了，像纤维一样。")])])])]),t._v(" "),e("h4",{attrs:{id:"_3-3-实现思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-实现思路"}},[t._v("#")]),t._v(" 3.3 实现思路")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("在 Fiber 方案中，为了实现任务的终止再继续，DOM比对算法被分成了两部分：")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("虚拟dom的比对：该过程是可以终止")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("真实dom对象的更新：该过程是不能终止的")])])])])]),t._v(" "),e("li",[e("p",[t._v("具体过程：")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("我们写的还是jsx，babel会将jsx转为 React.createElement()")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("React.createElement()返回的是虚拟dom")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[t._v("接下来就是执行第一阶段，即构建fiber对象。")])]),t._v(" "),e("ul",[e("li",[t._v("从最外层的虚拟dom，使用深度先序优先遍历的方式，找到内部的虚拟dom，然后为每个虚拟dom对象构建一个fiber对象，fiber对象（其实fiber对象就是普通的js对象，它是从虚拟dom对象演化而来的。）")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"4"}},[e("li",[t._v("当所有的fiber对象构建完成后，需要将这些fiber对象存储在数组中（在收集fiber对象的过程中是倒序收集的，即从左侧树的最后一个节点开始收集的）")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"5"}},[e("li",[t._v("然后执行第二个阶段（即commit阶段）：循环fiber数组，在循环的过程中，根据fiber中存储的当前节点执行操作的类型（即effectTag属性），该操作会应用到真实dom对象当中")])])])])]),t._v(" "),e("li",[e("p",[t._v("如果是DOM初始渲染: virtualDOM -> Fiber -> Fiber[] -> DOM")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("先通过 virtualDOM 对象构建fiber对象")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("把一个个的fiber对象存储到数组中")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[t._v("根据一个个的fiber中的操作的类型应用到真实dom对象中")])])])])]),t._v(" "),e("li",[e("p",[t._v("如果是DOM状态更新操作: newFiber vs oldFiber -> Fiber[] -> DOM")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("先重新构建所有fiber对象")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("再获取到旧的fiber对象进行比对")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[t._v("然后形成fiber数组 （注意：由于所有的fiber都被存储到数组中，那么一个个的fiber对象就应该需要有属性来表示谁是谁的父亲、儿子、兄弟）")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"4"}},[e("li",[t._v("再根据fiber的操作类型应用到真实dom对象中")])])])])])]),t._v(" "),e("h4",{attrs:{id:"_3-4-fiber-对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-fiber-对象"}},[t._v("#")]),t._v(" 3.4 Fiber 对象")]),t._v(" "),e("ul",[e("li",[t._v("fiber对象其实就是普通的js对象")])]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("{\n  // type 和 props 属性是虚拟dom对象演化来的 \n  type         节点类型 (元素, 文本, 组件)(具体的类型)\n  props        节点属性\n\n  stateNode    当前节点的真实DOM对象 | 组件实例对象\n  tag          节点标记 (对具体类型的分类 hostRoot || hostComponent || classComponent || functionComponent)， 可以区分出当前的fiber是类组件还是函数组件还是普通的dom节点\n  effects      数组, 存储需要更改的 fiber 对象，根fiber对象的此属性会保存所有fiber对象，而其他的子fiber会协助根fiber收集\n  effectTag    当前 Fiber 要被执行的操作 (新增, 删除, 修改)\n  parent       当前 Fiber 的父级 Fiber\n  child        当前 Fiber 的子级 Fiber\n  sibling      当前 Fiber 的下一个兄弟 Fiber\n  alternate    Fiber 备份 fiber 比对时使用\n}\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br")])]),e("blockquote",[e("p",[t._v("大儿子才是父亲的儿子节点，二儿子是大儿子的兄弟节点。只要有儿子，那么就一直往下找儿子\n"),e("img",{attrs:{src:i(1609),alt:""}})])])])}),[],!1,null,null,null);r.default=a.exports}}]);