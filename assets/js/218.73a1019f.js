(window.webpackJsonp=window.webpackJsonp||[]).push([[218],{2607:function(r,t,e){"use strict";e.r(t);var a=e(2),v=Object(a.a)({},(function(){var r=this,t=r.$createElement,a=r._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[r._v("#")]),r._v(" 前言")]),r._v(" "),a("p",[a("img",{attrs:{src:e(860),alt:""}})]),r._v(" "),a("h2",{attrs:{id:"dndprovider"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dndprovider"}},[r._v("#")]),r._v(" DndProvider")]),r._v(" "),a("ul",[a("li",[r._v("DndProvider 组件为您的应用程序提供 React-DnD 功能")]),r._v(" "),a("li",[r._v("使用时必须通过 backend 属性注入一个后端\n"),a("ul",[a("li",[r._v("backend: 必需属性 React DnD 后端")])])])]),r._v(" "),a("h2",{attrs:{id:"backend-后端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backend-后端"}},[r._v("#")]),r._v(" backend(后端)")]),r._v(" "),a("ul",[a("li",[r._v("React DnD 使用 HTML5 拖放 API。它会截取拖动的 DOM 节点并将其用作开箱即用的拖动预览。 当光标移动时，您不必进行任何绘图，这很方便")]),r._v(" "),a("li",[r._v("后端抽象出浏览器差异并处理原生 DOM 事件,并将 DOM 事件转换为 React DnD 可以处理的内部 Redux 操作")]),r._v(" "),a("li",[a("a",{attrs:{href:"https://react-dnd.github.io/react-dnd/docs/backends/html5",target:"_blank",rel:"noopener noreferrer"}},[r._v("react-dnd-html5-backend"),a("OutboundLink")],1),r._v(" 是 React-DnD 支持的主要后端,它本质上是使用 HTML5 拖放 API")]),r._v(" "),a("li",[r._v("HTML5 后端不支持触摸事件。 所以它不适用于平板电脑和移动设备。 您可以使用 "),a("a",{attrs:{href:"https://react-dnd.github.io/react-dnd/docs/backends/touch",target:"_blank",rel:"noopener noreferrer"}},[r._v("react-dnd-touch-backend"),a("OutboundLink")],1)])]),r._v(" "),a("h2",{attrs:{id:"dragdropmanager-管理器-和-registry-注册器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dragdropmanager-管理器-和-registry-注册器"}},[r._v("#")]),r._v(" DragDropManager(管理器)和 Registry(注册器)")]),r._v(" "),a("ul",[a("li",[r._v("管理整个拖拽应用")]),r._v(" "),a("li",[r._v("包含仓库和全局 monitor")]),r._v(" "),a("li",[r._v("全局 monitor 里包含 registry(注册器)")]),r._v(" "),a("li",[r._v("注册器里包含了 handlerId 和对应的 DragSource 或 DropTarget 的对应关系")]),r._v(" "),a("li",[r._v("每一个项目都会有一个唯一的 handlerId")])]),r._v(" "),a("h2",{attrs:{id:"items-and-types-项目和类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#items-and-types-项目和类型"}},[r._v("#")]),r._v(" Items and Types(项目和类型)")]),r._v(" "),a("ul",[a("li",[r._v("与 Redux 一样，React DnD 使用数据而不是视图作为来源")]),r._v(" "),a("li",[r._v("当您在屏幕上拖动某物时，我们并不是说正在拖动组件或 DOM 节点。 相反，我们说某种类型的项目正在被拖动")]),r._v(" "),a("li",[r._v("什么是项目？ 一个项目是一个简单的 JavaScript 对象，描述被拖动的内容。 例如，在看板应用程序中，当您拖动卡片时，项目可能看起来像是{type:'card', id: 'card1' }, 将拖动的数据描述为普通对象可以帮助您保持组件解耦")]),r._v(" "),a("li",[r._v("那什么是 type(类型)呢？ 类型是一个字符串(或 Symbol)，它唯一地标识了应用程序中的项目。 在看板应用程序中，您可能有一个代表可拖动卡片的卡片类型")]),r._v(" "),a("li",[r._v("类型很有用，因为随着您的应用程序的增长，您可能希望使更多内容可拖动，但您不一定希望所有现有的放置目标突然开始对新项目做出反应。 这些类型允许您指定兼容的拖放源和放置目标")])]),r._v(" "),a("p",[a("img",{attrs:{src:e(861),alt:""}})]),r._v(" "),a("h2",{attrs:{id:"monitors-监听器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#monitors-监听器"}},[r._v("#")]),r._v(" Monitors(监听器)")]),r._v(" "),a("ul",[a("li",[r._v("拖放本质上是有状态的。 要么正在进行拖动操作，要么不在。 要么有当前类型和当前项目，要么没有。 这种状态必须存在于某个地方")]),r._v(" "),a("li",[r._v("React DnD 通过监视器封装内部存储状态,并将此状态公开给您的组件")]),r._v(" "),a("li",[r._v("监视器允许您更新组件的属性以响应拖放状态的变化\n对于需要跟踪拖放状态的每个组件，您可以定义一个收集函数，从监视器获取它的相关属性")]),r._v(" "),a("li",[r._v("React DnD 然后负责及时调用您的收集函数并将其返回值合并到组件的属性对象中")])]),r._v(" "),a("h3",{attrs:{id:"dragsourcemonitor-拖动源监听器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dragsourcemonitor-拖动源监听器"}},[r._v("#")]),r._v(" DragSourceMonitor(拖动源监听器)")]),r._v(" "),a("ul",[a("li",[r._v("DragSourceMonitor 是传递给基于钩子或基于装饰器的拖动源的收集函数的对象")]),r._v(" "),a("li",[r._v("它的方法可让您获取有关特定拖动源的拖动状态的信息")]),r._v(" "),a("li",[r._v("绑定到该监视器的特定拖动源在下面称为监视器的所有者")]),r._v(" "),a("li",[r._v("方法\n"),a("ul",[a("li",[r._v("isDragging(): 如果拖动操作正在进行中，并且所有者发起拖动，则返回 true")]),r._v(" "),a("li",[r._v("getItemType(): 返回标识当前拖动项目类型的字符串或 Symbol")]),r._v(" "),a("li",[r._v("getItem(): 返回一个表示当前拖动项目的普通对象。 每个拖动源都必须通过从其 beginDrag() 方法返回一个对象来指定它")]),r._v(" "),a("li",[r._v("getClientOffset(): 在拖动操作正在进行时，返回最后记录的 { x, y } 鼠标的客户端偏移量")])])])]),r._v(" "),a("h3",{attrs:{id:"droptargetmonitor-放置目标监听器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#droptargetmonitor-放置目标监听器"}},[r._v("#")]),r._v(" DropTargetMonitor(放置目标监听器)")]),r._v(" "),a("ul",[a("li",[r._v("DropTargetMonitor 是传递给基于钩子或基于装饰器的收集函数的对象")]),r._v(" "),a("li",[r._v("它的方法可让您获取有关特定放置目标的拖动状态的信息")]),r._v(" "),a("li",[r._v("绑定到该监视器的特定放置目标在下面称为监视器的所有者")]),r._v(" "),a("li",[r._v("方法\n"),a("ul",[a("li",[r._v("getItemType(): 返回标识当前拖动项目类型的字符串或 Symbol")]),r._v(" "),a("li",[r._v("getItem(): 返回一个表示当前拖动项目的普通对象。 每个拖动源都必须通过从其 beginDrag() 方法返回一个对象来指定它")]),r._v(" "),a("li",[r._v("getClientOffset(): 在拖动操作正在进行时，返回最后记录的 { x, y } 鼠标的客户端偏移量")])])])]),r._v(" "),a("h2",{attrs:{id:"connectors-连接器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#connectors-连接器"}},[r._v("#")]),r._v(" Connectors(连接器)")]),r._v(" "),a("ul",[a("li",[r._v("如果后端处理 DOM 事件，但是组件使用 React 来描述 DOM，后端如何知道要监听哪些 DOM 节点？")]),r._v(" "),a("li",[r._v("连接器允许您将预定义角色之一（拖动源或放置目标）分配给渲染函数中的 DOM 节点")]),r._v(" "),a("li",[r._v("事实上，连接器作为第一个参数传递给我们上面描述的收集函数")]),r._v(" "),a("li",[r._v("在组件的渲染方法中，我们可以访问从监视器获得的数据和从连接器获得的函数")])]),r._v(" "),a("h3",{attrs:{id:"dragsourceconnector-拖动源连接器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dragsourceconnector-拖动源连接器"}},[r._v("#")]),r._v(" DragSourceConnector(拖动源连接器)")]),r._v(" "),a("ul",[a("li",[r._v("DragSourceConnector 是传递给 DragSource 的收集函数的对象")]),r._v(" "),a("li",[r._v("它提供了将 React 组件绑定到 Drag Source 角色的能力")]),r._v(" "),a("li",[r._v("属性\n"),a("ul",[a("li",[r._v("dragSource 返回一个必须被 prop-injected 到你的组件中并在该组件的 render() 方法中使用的函数。 您可以将此函数传递给此方法一个 react 组件、一个 DOM 元素或一个 ref 对象")])])])]),r._v(" "),a("h3",{attrs:{id:"dragtargetconnector-放置目标连接器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dragtargetconnector-放置目标连接器"}},[r._v("#")]),r._v(" DragTargetConnector(放置目标连接器)")]),r._v(" "),a("ul",[a("li",[r._v("DropTargetConnector 是传递给 DropTarget 的收集函数的对象。 它提供了将 React 组件绑定到 Drop Target 角色的能力")]),r._v(" "),a("li",[r._v("属性\n"),a("ul",[a("li",[r._v("dropTarget() => (Element | Node | Ref) 返回一个必须被 prop-injected 到你的组件中并在该组件的 render() 方法中使用的函数。 您可以将此函数传递给此方法一个 react 组件、一个 DOM 元素或一个 ref 对象")])])])]),r._v(" "),a("h2",{attrs:{id:"dragsources-拖动源-和-droptargets-放置目标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dragsources-拖动源-和-droptargets-放置目标"}},[r._v("#")]),r._v(" DragSources(拖动源)和 DropTargets(放置目标)")]),r._v(" "),a("ul",[a("li",[r._v("上面我们已经介绍了与 DOM 一起工作的后端、由项目和类型表示的数据以及收集功能，依靠监视器和连接器，这些功能让您可以描述 React DnD 应该注入到您的组件中的属性对象中")]),r._v(" "),a("li",[r._v("但是我们如何配置我们的组件来实际注入这些属性对象中呢？ 我们如何执行响应拖放事件的副作用？React DnD 的主要抽象单元拖动源和放置目标可以将类型、项目、副作用和收集功能与您的组件联系在一起")]),r._v(" "),a("li",[r._v("每当您想让一个组件或其某些部分可拖动时，您需要将该组件包装到拖动源声明中。 每个拖动源都针对特定类型注册，并且必须实现一个方法，从组件的 props 生成一个项目。 拖动源声明还允许您为给定组件指定收集功能")]),r._v(" "),a("li",[r._v("放置目标与拖动源非常相似。 唯一的区别是单个放置目标可以同时注册多个项目类型")])]),r._v(" "),a("h3",{attrs:{id:"dragsource"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dragsource"}},[r._v("#")]),r._v(" DragSource")]),r._v(" "),a("ul",[a("li",[r._v("参数\n"),a("ul",[a("li",[r._v("type: 必需的。 一个字符串、一个符号或一个函数，返回给定组件的属性。 只有为相同类型注册的放置目标才会对此拖动源生成的项目做出反应")]),r._v(" "),a("li",[r._v("spec: 必需的。 一个简单的 JavaScript 对象，上面有一些允许的方法。 它描述了拖动源如何对拖放事件做出反应\n"),a("ul",[a("li",[r._v("beginDrag(props, monitor, component): 必需的。 当拖动开始时，beginDrag 被调用。 您必须返回一个描述被拖动数据的普通 JavaScript 对象。 您返回的是有关拖放源的放置目标可用的唯一信息，因此选择他们需要知道的最少数据很重要")])])]),r._v(" "),a("li",[r._v("collect: 必需的。 收集功能。 它应该返回一个普通的属性对象以注入到您的组件中。 它接收两个参数：connect 和 monitor")])])])]),r._v(" "),a("h3",{attrs:{id:"droptarget"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#droptarget"}},[r._v("#")]),r._v(" DropTarget")]),r._v(" "),a("ul",[a("li",[r._v("参数\n"),a("ul",[a("li",[r._v("types: 必需的。 给定组件的 props，一个字符串、一个符号、一个数组或一个返回其中任何一个的函数。 这个放置目标只会对指定类型的拖拽源产生的项目做出反应")]),r._v(" "),a("li",[r._v("spec: 必需的。 一个简单的 JavaScript 对象，上面有一些允许的方法。 它描述了放置目标如何对拖放事件做出反应\n"),a("ul",[a("li",[r._v("hover(props, monitor, component): 可选的。 当项目悬停在组件上时调用")])])]),r._v(" "),a("li",[r._v("collect: 必需的。 收集功能。 它应该返回一个普通的属性对象以注入到您的组件中。 它接收两个参数：connect 和 monitor")])])])]),r._v(" "),a("h2",{attrs:{id:"usedrag"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usedrag"}},[r._v("#")]),r._v(" useDrag")]),r._v(" "),a("ul",[a("li",[r._v("useDrag hook 提供了一种将组件作为拖动源连接到 DnD 系统的方法")]),r._v(" "),a("li",[r._v("通过将规范传入 useDrag，您可以声明性地描述正在生成的可拖动的类型、表示拖动源的项目对象、要收集的属性等")]),r._v(" "),a("li",[r._v("useDrag hooks 返回几个关键项：收集的属性，以及可能附加到拖动源的 refs")]),r._v(" "),a("li",[r._v("参数\n"),a("ul",[a("li",[r._v("spec 规范对象或创建规范对象的函数\n"),a("ul",[a("li",[r._v("type: 必需的。 这必须是字符串或 Symbol。 只有为相同类型注册的放置目标才会对此项目做出反应")]),r._v(" "),a("li",[r._v("item: 必需的 (对象或者函数) 当这是一个对象时，它是一个描述被拖动数据的普通 JavaScript 对象。 这是拖放目标唯一可用的有关拖动源的信息。当这是一个函数时，它在拖动操作开始时被触发，并返回一个表示拖动操作的对象")]),r._v(" "),a("li",[r._v("collect: 可选的。 收集功能。 它应该返回一个普通的属性对象，以返回以注入到您的组件属性中。 它接收两个参数，monitor 和 props")])])])])]),r._v(" "),a("li",[r._v("返回值数组\n"),a("ul",[a("li",[r._v("[0] - Collected Props: 包含从 collect 函数收集的属性的对象。 如果没有定义 collect 函数，则返回一个空对象")]),r._v(" "),a("li",[r._v("[1] - DragSource Ref: 拖动源的连接器功能。 这必须附加到 DOM 的可拖动部分")])])])]),r._v(" "),a("h2",{attrs:{id:"usedrop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usedrop"}},[r._v("#")]),r._v(" useDrop")]),r._v(" "),a("ul",[a("li",[r._v("useDrop hook 为您提供了一种将组件连接到 DnD 系统作为放置目标的方法")]),r._v(" "),a("li",[r._v("通过将规范传入 useDrop hook，您可以指定放置目标将接受哪些类型的数据项，要收集哪些属性，等等")]),r._v(" "),a("li",[r._v("此函数返回一个要附加到 Drop Target 节点的 ref 和收集到的属性")]),r._v(" "),a("li",[r._v("参数\n"),a("ul",[a("li",[r._v("specA 规范对象或创建规范对象的函数\n"),a("ul",[a("li",[r._v("accept 必填项 一个字符串或一个 Symbol,这个放置目标只会对指定类型的拖拽源产生的项目做出反应")]),r._v(" "),a("li",[r._v("collect: 可选的。收集功能。 它应该返回一个普通的属性对象，以返回以注入到您的组件属性中。 它接收两个参数，monitor 和 props")]),r._v(" "),a("li",[r._v("hover(item, monitor): 可选的。 当在组件发生 hover 事件时调用")])])])])]),r._v(" "),a("li",[r._v("返回值\n"),a("ul",[a("li",[r._v("Collected Props: 包含从 collect 函数收集的属性的对象。 如果没有定义 collect function，则返回一个空对象")]),r._v(" "),a("li",[r._v("DropTarget Ref: 放置目标的连接器函数。 这必须附加到 DOM 的放置目标部分")])])])])])}),[],!1,null,null,null);t.default=v.exports},860:function(r,t,e){r.exports=e.p+"assets/img/2.e4584318.png"},861:function(r,t,e){r.exports=e.p+"assets/img/3.f8daec75.png"}}]);