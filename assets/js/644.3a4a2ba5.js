(window.webpackJsonp=window.webpackJsonp||[]).push([[644],{2394:function(e,_,v){"use strict";v.r(_);var t=v(2),r=Object(t.a)({},(function(){var e=this,_=e.$createElement,v=e._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("p",[e._v("Title")]),e._v(" "),v("p",[e._v("课前须知：")]),e._v(" "),v("ul",[v("li",[e._v("为了更好的学习体验，请购课后加卡颂微信（kasong555），发送"),v("a",{attrs:{href:"https://wechatapppro-1252524126.file.myqcloud.com/appjiz2zqrn2142/image/b_u_622f2474a891b_tuQ1ZmhR/lbfu8mqw0ssm.jpeg",target:"_blank",rel:"noopener noreferrer"}},[e._v("课程订单号"),v("OutboundLink")],1),e._v("，拉你进专属学习群")]),e._v(" "),v("li",[e._v("参与"),v("a",{attrs:{href:"https://wj.qq.com/s2/11444184/b3e4/",target:"_blank",rel:"noopener noreferrer"}},[e._v("2 个月通关 React 挑战"),v("OutboundLink")],1),e._v("，返现金")]),e._v(" "),v("li",[e._v("为了提高 PC 端观看体验，请安装"),v("a",{attrs:{href:"https://github.com/BetaSu/kasong-school",target:"_blank",rel:"noopener noreferrer"}},[e._v("卡颂课堂 chrome 插件"),v("OutboundLink")],1)]),e._v(" "),v("li",[v("a",{attrs:{href:"https://github.com/BetaSu/big-react/commit/8f38c7357393fe6b645b44930a7e4ac4f921684e",target:"_blank",rel:"noopener noreferrer"}},[e._v("本节课代码地址"),v("OutboundLink")],1)])]),e._v(" "),v("h1",{attrs:{id:"第十二课-实现-diff-算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第十二课-实现-diff-算法"}},[e._v("#")]),e._v(" 第十二课：实现 Diff 算法")]),e._v(" "),v("p",[e._v("当前仅实现了单一节点的**「增/删操作」"),v("strong",[e._v("，即")]),e._v("「单节点 Diff 算法」"),v("strong",[e._v("。本节课实现")]),e._v("「多节点的 Diff 算法」**。")]),e._v(" "),v("p",[e._v("本节课采用简写示例：A1 -> A2")]),e._v(" "),v("h2",{attrs:{id:"对于-reconcilesingleelement-的改动"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对于-reconcilesingleelement-的改动"}},[e._v("#")]),e._v(" 对于 reconcileSingleElement 的改动")]),e._v(" "),v("p",[e._v("当前支持的情况：")]),e._v(" "),v("ul",[v("li",[e._v("A1 -> B1")]),e._v(" "),v("li",[e._v("A1 -> A2")])]),e._v(" "),v("p",[e._v("需要支持的情况：")]),e._v(" "),v("ul",[v("li",[e._v("ABC -> A")])]),e._v(" "),v("p",[v("strong",[e._v("「单/多节点」"),v("strong",[e._v("是指")]),e._v("「更新后是单/多节点」")]),e._v("。")]),e._v(" "),v("p",[e._v("更细致的，我们需要区分 4 种情况：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("key")]),e._v("相同，"),v("code",[e._v("type")]),e._v("相同 == 复用当前节点")])]),e._v(" "),v("p",[e._v("例如：A1 B2 C3 -> A1")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("key")]),e._v("相同，"),v("code",[e._v("type")]),e._v("不同 == 不存在任何复用的可能性")])]),e._v(" "),v("p",[e._v("例如：A1 B2 C3 -> B1")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("key")]),e._v("不同，"),v("code",[e._v("type")]),e._v("相同  == 当前节点不能复用")]),e._v(" "),v("li",[v("code",[e._v("key")]),e._v("不同，"),v("code",[e._v("type")]),e._v("不同 == 当前节点不能复用")])]),e._v(" "),v("h2",{attrs:{id:"对于-reconcilesingletextnode-的改动"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对于-reconcilesingletextnode-的改动"}},[e._v("#")]),e._v(" 对于 reconcileSingleTextNode 的改动")]),e._v(" "),v("p",[e._v("类似"),v("code",[e._v("reconcileSingleElement")]),e._v("。")]),e._v(" "),v("h2",{attrs:{id:"对于同级多节点-diff-的支持"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对于同级多节点-diff-的支持"}},[e._v("#")]),e._v(" 对于同级多节点 Diff 的支持")]),e._v(" "),v("p",[e._v("单节点需要支持的情况：")]),e._v(" "),v("ul",[v("li",[e._v("插入 "),v("code",[e._v("Placement")])]),e._v(" "),v("li",[e._v("删除 "),v("code",[e._v("ChildDeletion")])])]),e._v(" "),v("p",[e._v("多节点需要支持的情况：")]),e._v(" "),v("ul",[v("li",[e._v("插入 "),v("code",[e._v("Placement")])]),e._v(" "),v("li",[e._v("删除 "),v("code",[e._v("ChildDeletion")])]),e._v(" "),v("li",[e._v("移动 "),v("code",[e._v("Placement")])])]),e._v(" "),v("p",[e._v("整体流程分为 4 步。")]),e._v(" "),v("ol",[v("li",[e._v("将"),v("code",[e._v("current")]),e._v("中所有同级"),v("code",[e._v("fiber")]),e._v("保存在"),v("code",[e._v("Map")]),e._v("中")]),e._v(" "),v("li",[e._v("遍历"),v("code",[e._v("newChild")]),e._v("数组，对于每个遍历到的"),v("code",[e._v("element")]),e._v("，存在两种情况：")])]),e._v(" "),v("ul",[v("li",[e._v("在"),v("code",[e._v("Map")]),e._v("中存在对应"),v("code",[e._v("current fiber")]),e._v("，且可以复用")]),e._v(" "),v("li",[e._v("在"),v("code",[e._v("Map")]),e._v("中不存在对应"),v("code",[e._v("current fiber")]),e._v("，或不能复用")])]),e._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[e._v("判断是插入还是移动")]),e._v(" "),v("li",[e._v("最后"),v("code",[e._v("Map")]),e._v("中剩下的都标记删除")])]),e._v(" "),v("h2",{attrs:{id:"步骤-2-是否复用-详解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#步骤-2-是否复用-详解"}},[e._v("#")]),e._v(" 步骤 2 —— 是否复用 详解")]),e._v(" "),v("p",[e._v("首先，根据"),v("code",[e._v("key")]),e._v("从"),v("code",[e._v("Map")]),e._v("中获取"),v("code",[e._v("current fiber")]),e._v("，如果不存在"),v("code",[e._v("current fiber")]),e._v("，则没有复用的可能。")]),e._v(" "),v("p",[e._v("接下来，分情况讨论：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("element")]),e._v("是"),v("code",[e._v("HostText")]),e._v("，"),v("code",[e._v("current fiber")]),e._v("是么？")]),e._v(" "),v("li",[v("code",[e._v("element")]),e._v("是其他"),v("code",[e._v("ReactElement")]),e._v("，"),v("code",[e._v("current fiber")]),e._v("是么？")]),e._v(" "),v("li",[e._v("TODO "),v("code",[e._v("element")]),e._v("是数组或"),v("code",[e._v("Fragment")]),e._v("，"),v("code",[e._v("current fiber")]),e._v("是么？")])]),e._v(" "),v("p",[v("code",[e._v("<ul> <li/> <li/> {[<li/>, <li/>]} </ul> <ul> <li/> <li/> <> <li/> <li/> </> </ul>")])]),e._v(" "),v("h2",{attrs:{id:"步骤-3-插入-移动判断-详解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#步骤-3-插入-移动判断-详解"}},[e._v("#")]),e._v(" 步骤 3 —— 插入/移动判断 详解")]),e._v(" "),v("p",[v("strong",[e._v("「移动」"),v("strong",[e._v("具体是指")]),e._v("「向右移动」")])]),e._v(" "),v("p",[e._v("移动的判断依据："),v("code",[e._v("element")]),e._v("的"),v("code",[e._v("index")]),e._v("与**「element 对应 current fiber」**的"),v("code",[e._v("index")]),e._v("的比较")]),e._v(" "),v("p",[e._v("A1 B2 C3 -> B2 C3 A1")]),e._v(" "),v("p",[e._v("0__1__2______0__1__2")]),e._v(" "),v("p",[e._v("当遍历"),v("code",[e._v("elemen")]),e._v("t 时，**「当前遍历到的 element」"),v("strong",[e._v("一定是")]),e._v("「所有已遍历的 element」**中最靠右那个。")]),e._v(" "),v("p",[e._v("所以只需要记录**「最后一个可复用 fiber」**在"),v("code",[e._v("current")]),e._v("中的"),v("code",[e._v("index")]),e._v("（"),v("code",[e._v("lastPlacedIndex")]),e._v("），在接下来的遍历中：")]),e._v(" "),v("ul",[v("li",[e._v("如果接下来遍历到的**「可复用 fiber」**的"),v("code",[e._v("index")]),e._v(" < "),v("code",[e._v("lastPlacedIndex")]),e._v("，则标记"),v("code",[e._v("Placement")])]),e._v(" "),v("li",[e._v("否则，不标记")])]),e._v(" "),v("h2",{attrs:{id:"移动操作的执行"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#移动操作的执行"}},[e._v("#")]),e._v(" 移动操作的执行")]),e._v(" "),v("p",[v("code",[e._v("Placement")]),e._v("同时对应：")]),e._v(" "),v("ul",[v("li",[e._v("移动")]),e._v(" "),v("li",[e._v("插入")])]),e._v(" "),v("p",[e._v("对于插入操作，之前对应的"),v("code",[e._v("DOM")]),e._v("方法是"),v("code",[e._v("parentNode.appendChild")]),e._v("，现在为了实现移动操作，需要支持"),v("code",[e._v("parentNode.insertBefore")]),e._v("。")]),e._v(" "),v("p",[v("code",[e._v("parentNode.insertBefore")]),e._v("需要找到**「目标兄弟 Host 节点」**，要考虑 2 个因素：")]),e._v(" "),v("ul",[v("li",[e._v("可能并不是目标 fiber 的直接兄弟节点")])]),e._v(" "),v("p",[v("code",[e._v("// 情况1 <A/><B/> function B() { return <div/>; } // 情况2 <App/><div/> function App() { return <A/>; }")])]),e._v(" "),v("ul",[v("li",[e._v("不稳定的"),v("code",[e._v("Host")]),e._v("节点不能作为**「目标兄弟 Host 节点」**")])]),e._v(" "),v("h2",{attrs:{id:"不足"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#不足"}},[e._v("#")]),e._v(" 不足")]),e._v(" "),v("ul",[v("li",[e._v("不支持数组与"),v("code",[e._v("Fragment")])])]),e._v(" "),v("p",[v("code",[e._v("<> <div/> <div/> </> <ul> <li/> <li/> {[<li/>, <li/>]} </ul>")])]),e._v(" "),v("ul",[v("li",[e._v("可能有未考虑到的边界情况")])]),e._v(" "),v("p",[e._v("需要覆盖所有相关用例"),v("a",{attrs:{href:"https://github.com/facebook/react/blob/main/packages/react-dom/src/__tests__/ReactMultiChildReconcile-test.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("ReactMultiChildReconcile-test.js"),v("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=r.exports}}]);