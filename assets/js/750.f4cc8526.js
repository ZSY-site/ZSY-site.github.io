(window.webpackJsonp=window.webpackJsonp||[]).push([[750],{2516:function(t,v,l){"use strict";l.r(v);var _=l(2),s=Object(_.a)({},(function(){var t=this,v=t.$createElement,l=t._self._c||v;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h2",{attrs:{id:"线程与进程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#线程与进程"}},[t._v("#")]),t._v(" 线程与进程")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("1.多线程：每次请求都会开启新的进程")]),t._v(" "),l("ul",[l("li",[t._v("优点：可以同时处理多个请求")]),t._v(" "),l("li",[t._v("缺点：使用的是切换时间片的概念，浪费性能，同时开启了多个进程浪费内存")]),t._v(" "),l("li",[t._v("场景:适合cpu密集型（压缩，合算，计算）")])])]),t._v(" "),l("li",[l("p",[t._v("node是单线程，单进程的: 不适用cpu密集型，适合 I/O密集（文件的读写）")]),t._v(" "),l("ul",[l("li",[t._v("node应用：解决跨域，中间层，ssr服务端渲染，纯服务端")]),t._v(" "),l("li",[t._v("说明:node只有一个主线程，理论上只占一核，此时不能很好的利用cpu，但是node可以开子进程")])])])]),t._v(" "),l("p",[t._v("一个进程占用一个核（cpu）")]),t._v(" "),l("h2",{attrs:{id:"js单线程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#js单线程"}},[t._v("#")]),t._v(" JS单线程")]),t._v(" "),l("ul",[l("li",[t._v("javascript在最初设计时设计成了单线程,为什么不是多线程呢？如果多个线程同时操作DOM那岂不会很混乱？这里所谓的单线程指的是主线程是单线程的,所以在Node中主线程依旧是单线程的。\n"),l("ul",[l("li",[t._v("单线程特点是节约了内存,并且不需要在切换执行上下文")]),t._v(" "),l("li",[t._v("而且单线程不需要管锁的问题.")]),t._v(" "),l("li",[t._v("单线程的解决方案是 【异步】")])])])])])}),[],!1,null,null,null);v.default=s.exports}}]);