(window.webpackJsonp=window.webpackJsonp||[]).push([[846],{2640:function(t,a,s){"use strict";s.r(a);var e=s(2),o=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"面试题汇总"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题汇总"}},[t._v("#")]),t._v(" 面试题汇总")]),t._v(" "),s("h3",{attrs:{id:"谈谈你对hook的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对hook的理解"}},[t._v("#")]),t._v(" 谈谈你对Hook的理解")]),t._v(" "),s("ul",[s("li",[t._v("是什么？\n"),s("ul",[s("li",[t._v("Hook 是 React 16.8 的新增特性。hooks都是函数，会以use开头")])])]),t._v(" "),s("li",[t._v("能干什么？干的怎么样？\n"),s("ul",[s("li",[t._v("它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性")]),t._v(" "),s("li",[t._v("如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使用 Hook")])])])]),t._v(" "),s("h2",{attrs:{id:"解决的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决的问题"}},[t._v("#")]),t._v(" 解决的问题")]),t._v(" "),s("ul",[s("li",[t._v("在组件之间复用状态逻辑很难,可能要用到render props和高阶组件，React 需要为共享状态逻辑提供更好的原生途径，Hook 使你在无需修改组件结构的情况下复用状态逻辑")]),t._v(" "),s("li",[t._v("复杂组件变得难以理解，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）")]),t._v(" "),s("li",[t._v("难以理解的 class,包括难以捉摸的this")])]),t._v(" "),s("h2",{attrs:{id:"注意事项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[t._v("#")]),t._v(" 注意事项")]),t._v(" "),s("ul",[s("li",[t._v("只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。")]),t._v(" "),s("li",[t._v("只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用")])])])}),[],!1,null,null,null);a.default=o.exports}}]);