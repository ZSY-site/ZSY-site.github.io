(window.webpackJsonp=window.webpackJsonp||[]).push([[357],{1295:function(t,e,r){t.exports=r.p+"assets/img/403.3f3bb341.png"},2926:function(t,e,r){"use strict";r.r(e);var a=r(2),l=Object(a.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[a("a",{attrs:{href:"https://blog.csdn.net/qq_42072086/article/details/106986201",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考文章"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"核心点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心点"}},[t._v("#")]),t._v(" 核心点")]),t._v(" "),a("ul",[a("li",[t._v("因为如果不采用异步更新/渲染，那么每次更新数据都会对当前组件进行重新渲染。所以为了性能考虑，Vue会在本轮数据更新后，再去异步更新视图！")]),t._v(" "),a("li",[t._v("Vue是组件级更新，即组件中某个数据改变了，就会去更新组件，这样性能肯定不高，因此采用的是异步更新（和兴方法就是nextTick）")]),t._v(" "),a("li",[t._v("异步更新：如果同一组件中有多个数据改变的话，那么对于是同一个watcher，则它会先进行过滤")])]),t._v(" "),a("h2",{attrs:{id:"具体实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#具体实现"}},[t._v("#")]),t._v(" 具体实现")]),t._v(" "),a("ul",[a("li",[a("ol",[a("li",[t._v("当数据变化的时候，就会调用 notify方法，通知watcher进行更新操作")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[t._v("这个watcher会去调用update方法进行更新，在进行更新的时候并不是让watcher立即执行")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"3"}},[a("li",[t._v("而是调用 queueWatcher 方法先对所有的watcher进行过滤，即对于相同的watcher，它只会存一个。然后再将过滤后的watcher放到队列中")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"4"}},[a("li",[t._v("然后通过nextTick异步执行flushSchedulerQueue方法刷新watcher队列。")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"5"}},[a("li",[t._v("flushSchedulerQueue中开始会触发一个before的方法，其实就是beforeUpdate，然后watcher.run() 才开始真正执行watcher，执行完页面就渲染完成啦，更新完成后会调用updated钩子。")])])])]),t._v(" "),a("p",[a("img",{attrs:{src:r(1295),alt:""}})])])}),[],!1,null,null,null);e.default=l.exports}}]);