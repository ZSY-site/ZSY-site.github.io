(window.webpackJsonp=window.webpackJsonp||[]).push([[1451],{3480:function(v,_,l){"use strict";l.r(_);var i=l(2),e=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("ul",[l("li",[l("p",[v._v("很好地解决了“碎片”问题的存储管理方法是 "),l("code",[v._v("页式存储管理")])])]),v._v(" "),l("li",[l("p",[v._v("实现虚拟存储器的目的是 "),l("code",[v._v("扩充主存容量")])])]),v._v(" "),l("li",[l("p",[l("code",[v._v("交换技术")]),v._v(" 是指将作业不需要或暂时不需要的部分移到外存，让出内存空间以调入其他所需数据。")])]),v._v(" "),l("li",[l("p",[v._v("把作业地址空间中使用的逻辑地址变成内存中物理地址的过程称为 "),l("code",[v._v("重定位")])])]),v._v(" "),l("li",[l("p",[v._v("某操作系统对内存的管理采用页式存储管理方法，所划分的页面大小 "),l("code",[v._v("必须相同")])])]),v._v(" "),l("li",[l("p",[v._v("将主存空闲区按地址顺序从小到大登记在空闲分区表中，每次分配时总是顺序查找空闲区表中第一个满足需求的空闲分区切割，这种分配算法称为 "),l("code",[v._v("最先适应")])])]),v._v(" "),l("li",[l("p",[v._v("可变分区存储管理采用的地址转换公式是 "),l("code",[v._v("绝对地址=基址寄存器值+逻辑地址")]),v._v("  ???")])]),v._v(" "),l("li",[l("p",[v._v("虚拟存储器的容量是由计算机的地址结构决定的，若CPU有32位地址，则它的虚拟地址空间为 "),l("code",[v._v("4G")]),v._v(" ???")])]),v._v(" "),l("li",[l("p",[v._v("在虚拟分页存储管理系统中，若进程访问的页面不在主存，且主存中没有可用的空闲帧时，系统正确的处理顺序为 "),l("code",[v._v("缺页中断→确定淘汰页→页面调出→页面调入")])])]),v._v(" "),l("li",[l("p",[v._v("在目标程序装入内存时，一次性完成地址修改的方式 "),l("code",[v._v("静态重定位")])])]),v._v(" "),l("li",[l("p",[v._v("在分页管理中使用单级页表，如果不用快表时，每访问一个物理地址，需要访问内存 "),l("code",[v._v("2")]),v._v(" 次")])]),v._v(" "),l("li",[l("p",[v._v("虚拟存储管理策略可以 "),l("code",[v._v("扩大逻辑内存容量")])])]),v._v(" "),l("li",[l("p",[v._v("采用 "),l("code",[v._v("分段式存储管理")]),v._v(" 不会产生内部碎片。")])]),v._v(" "),l("li",[l("p",[v._v("把作业地址空间中使用的逻辑地址变成内存中物理地址的过程称为 "),l("code",[v._v("重定位")])])]),v._v(" "),l("li",[l("p",[v._v("首次适应算法的空闲区是 "),l("code",[v._v("按地址递增顺序连在一起")])])]),v._v(" "),l("li",[l("p",[v._v("动态重定位是在作业的 "),l("code",[v._v("执行")]),v._v(" 过程中进行的。")])]),v._v(" "),l("li",[l("p",[v._v("实现虚拟内存最主要的技术是 "),l("code",[v._v("部分对换")])])]),v._v(" "),l("li",[l("p",[v._v("用段式存储管理的系统中，若地址用24位表示，其中8位表示段号，则允许每段的最大长度是 "),l("code",[v._v("2^16")]),v._v(" 2的16次方")])]),v._v(" "),l("li",[l("p",[v._v("动态重定位技术依赖于 "),l("code",[v._v("地址机构")])])]),v._v(" "),l("li",[l("p",[v._v("很好地解决了“碎片”问题的存储管理方法是 "),l("code",[v._v("页式存储管理")])])]),v._v(" "),l("li",[l("p",[v._v("分页存储管理中，页表中的内容是 "),l("code",[v._v("分配给逻辑空间的某个页面的内存块的块号")])])]),v._v(" "),l("li",[l("p",[v._v("在分段存储管理方式中，以段为单位，每段是一个 "),l("code",[v._v("连续存储区")])])]),v._v(" "),l("li",[l("p",[l("code",[v._v("固定分区")]),v._v(" 存储管理支持多道程序设计，算法简单，但存储碎片多。")])]),v._v(" "),l("li",[l("p",[v._v("虚拟存储管理系统的基础是程序的 "),l("code",[v._v("局部性")]),v._v(" 理论。")])]),v._v(" "),l("li",[l("p",[v._v("在有虚拟存储器的系统中，可以运行比主存容量还大的程序。")])]),v._v(" "),l("li",[l("p",[v._v("在请求页式存储管理中，若所需页面不在内存中，则会引起缺页中断。")])]),v._v(" "),l("li",[l("p",[v._v("线程是运行的调度单位，但不是资源的拥有单位。")])]),v._v(" "),l("li",[l("p",[v._v("试述请求分页虚拟存储器的实现原理。")]),v._v(" "),l("ul",[l("li",[v._v("请求分页虚存管理方法: 在分页管理的基础上增加了请求调页、页面置换等功能。它允许用户进程只装入部分页面就可以启动运行，而非全部装入。在运行中通过调页功能和置换功能陆续把要运行的页面调入内存，并将暂不运行的页面换出到外存上。")])])]),v._v(" "),l("li",[l("p",[v._v("分页存储管理和分段存储管理有什么异同？")]),v._v(" "),l("ul",[l("li",[v._v("单位不同：页是物理单位。段是逻辑单位")]),v._v(" "),l("li",[v._v("目的不同：分页目的是提高内存的使用率。分段目的是方便用户使用。")]),v._v(" "),l("li",[v._v("大小不同：页的大小是固定的由系统决定。段的大小不固定且由用户决定。")]),v._v(" "),l("li",[v._v("地址空间不同：分页作业的地址空间是一维的。分段作业的地址空间是二维的。")])])]),v._v(" "),l("li",[l("p",[v._v("段式和页式存储管理，从地址结构看，它们有什么实质性差异？")]),v._v(" "),l("ul",[l("li",[v._v("逻辑地址不同：页式的逻辑地址是连续的，段式的逻辑地址可以不连续。")]),v._v(" "),l("li",[v._v("地址是一维还是二维：页式的地址是一维的，段式的地址是二维的。")]),v._v(" "),l("li",[v._v("由谁来确定：分页是操作系统进行，分段是用户确定")]),v._v(" "),l("li",[v._v("连续还是分散：各页可以分散存放在主存，每段必须占用连续的主存空间。")]),v._v(" "),l("li",[v._v("是否固定: 页长是固定的，段长是不是固定的；")])])]),v._v(" "),l("li",[l("p",[v._v("在存储管理中分页与分段的主要区别是什么？分页与分段两种方法中，哪个更易于实现共享？")]),v._v(" "),l("ul",[l("li",[v._v("区别见上面。")]),v._v(" "),l("li",[v._v("在分段方式中，源程序（段号，段内位移）经连结装配后仍保持二维(地址)结构。相比较分段实现信息的共享和保护更容易些。")])])])])])}),[],!1,null,null,null);_.default=e.exports}}]);