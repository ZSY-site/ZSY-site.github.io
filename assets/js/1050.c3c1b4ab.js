(window.webpackJsonp=window.webpackJsonp||[]).push([[1050],{2933:function(e,t,r){"use strict";r.r(t);var a=r(2),v=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#理解"}},[e._v("#")]),e._v(" 理解")]),e._v(" "),r("h3",{attrs:{id:"要掌握每个生命周期什么时候被调用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#要掌握每个生命周期什么时候被调用"}},[e._v("#")]),e._v(" 要掌握每个生命周期什么时候被调用")]),e._v(" "),r("ul",[r("li",[e._v("beforeCreate：在实例初始化之后，数据观测（data observer） 之前被调用")]),e._v(" "),r("li",[e._v("created：实例已经创建之后被调用。在这一步，实例已完成以下的配置：数据观测（data observer）, 属性和方法的运算，watch/event 事件回调。这里没有 $el")]),e._v(" "),r("li",[e._v("beforeMount：在挂载开始之前被调用；相关的render函数首次被调用。")]),e._v(" "),r("li",[e._v("mounted：el 被创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子")]),e._v(" "),r("li",[e._v("beforeUpdate: 数据更新时调用，发生在虚拟DOM重新渲染和打补丁，在这之后会调用该钩子")]),e._v(" "),r("li",[e._v("destoryed: Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会接绑定，所有的事件监听会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。")])]),e._v(" "),r("h3",{attrs:{id:"要掌握每个生命周期内部可以做什么事"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#要掌握每个生命周期内部可以做什么事"}},[e._v("#")]),e._v(" 要掌握每个生命周期内部可以做什么事")]),e._v(" "),r("ul",[r("li",[e._v("create: 实例已经创建完成，因为它是最早触发的原因可以进行一些数据，资源的请求。")]),e._v(" "),r("li",[e._v("mounted: 实例已经挂载完成，可以进行一些DOM操作")]),e._v(" "),r("li",[e._v("beforeUpdate: 可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程")]),e._v(" "),r("li",[e._v("updated: 可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。")]),e._v(" "),r("li",[e._v("destoryed: 可以执行一些优化操作，清空定时器，解除绑定事件")])])])}),[],!1,null,null,null);t.default=v.exports}}]);